% GA4GH File Encryption Standard specification
% When editing, please start all sentences on a new line; and try to avoid source lines longer than 120 characters.
\documentclass[10pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage[pdfborder={0 0 0},hyperfootnotes=false]{hyperref}
\usepackage{parskip}
\usepackage{algpseudocode}
\usepackage{draftwatermark}
\newcommand{\mailtourl}[1]{\href{mailto:#1}{\tt #1}}
\newcommand{\tagvalue}[1]{\tt #1}
\newcommand{\tagregex}[1]{\tt #1}
\newcommand{\kw}[1]{\texttt{#1}}
\newlength{\maxwidth}
\newcommand{\algalign}[2] % #1 = text to left, #2 = text to right
{\makebox[\maxwidth][l]{$#1{}$}${}#2$}

\SetWatermarkAngle{315}
\SetWatermarkText{PRELIMINARY}
\SetWatermarkScale{4}

\begin{document}

\input{crypt4gh.ver}
\title{GA4GH File Encryption Standard}
\date{\headdate}
\maketitle
\begin{quote}\small
The master version of this document can be found at
\url{https://github.com/samtools/hts-specs}.\\
This printing is version~\commitdesc\ from that repository,
last modified on the date shown above.
\end{quote}
\vspace*{1em}

\begin{abstract}
This document describes the format for Global Alliance for Genomics and Health (GA4GH) encrypted and authenticated
files.
Encryption helps to prevent accidental disclosure of confidential information.
Allowing programs to directly read and write data in an encrypted format reduces the chance of such disclosure.
The format described here can be used to encrypt any underlying file format.
It also allows for seeking on the encrypted data.
In particular indexes on the plain text version can also be used on the encrypted file without modification.
\end{abstract}
\newpage
\tableofcontents
\newpage
\section{Introduction}
\subsection{Purpose}
By its nature, genomic data can include information of a confidential nature about the health of individuals.
It is important that such information is not accidentally disclosed.
One part of the defence against such disclosure is to, as much as possible, keep the data in an encrypted format.

This document describes a file format that can be used to store data in an encrypted and authenticated state.
Existing applications can, with minimal modification, read and write data in the encrypted format.
The choice of encryption also allows the encrypted data to be read starting from any location, facilitating indexed
access to files.

\subsection{Requirements}
The key words ``MUST'', ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL NOT'', ``SHOULD'', ``SHOULD NOT'',
``RECOMMENDED'', ``MAY'', and ``OPTIONAL'' in this document are to be interpreted as described in \cite{RFC2119}.

\subsection{Terminology}
\begin{description}
\item[Elliptic-curve cryptography (ECC)]
An approach to public-key cryptography based on the algebraic structure of elliptic curves over finite fields.

\item[Curve25519]
A widely used FIPS-140 approved ECC algorithm not encumbered by any patents \cite{RFC7748}.

\item[ChaCha20-IETF-Poly1305]
ChaCha20 is a symmetric stream cipher built on a pseudo-random function that gives the advantage that one can
efficiently seek to any position in the key stream in constant time.
It is not patented.
Poly1305 is a cryptographic message authentication code (MAC).
It can be used to verify the data integrity and the authenticity of a message \cite{RFC8439}.

\item[cipher-text]~\\
The encrypted version of the data.

\item[plain-text]~\\
The unencrypted version of the data.

\item[nonce]~\\
A number that is used only once.
Such numbers are used to set the initial state in cryptographic constructions.
It is important that they are not reused as it is possible for attackers to learn information about data blocks that
have been encrypted using the same key and nonce.
In the worst case this can lead to a complete break-down of the security of the encryption.

\item[MAC]~\\
Message authentication code.
A MAC is a short tag generated by an algorithm which takes a message and a secret key as inputs.
To be secure, it should be computationally infeasible to generate the same MAC without knowing the secret key.
A holder of the secret key can run a verification algorithm on the MAC to ensure with high probability that the
message has not been altered after the MAC was generated.

\end{description}

\section{Encrypted Representation Overview}
The encrypted file consists of the following parts:

\begin{itemize}
\item An unencrypted header, containing a ``magic'' string, version number and header packet count.

\item An sequence of one or more encrypted header packets.
These are encrypted using an asymmetric encryption algorithm and store the encryption keys and other parameters needed
to decrypt the encrypted data section.

Each header packet is encrypted for a single recipient.
To allow headers to be read by more than one recipient, readers should ignore any header packets for which they
do not have a valid key.

\item The encrypted data.
This is the actual application data.
It is encrypted using a symmetric encryption algorithm as described in the encrypted header.
\end{itemize}

\section{Detailed Specification}
\subsection{Overall Conventions}
\subsubsection{Hexadecimal Numbers}
Hexadecimal values are written using the digits 0-9, and letters a-f for values 10-15.
Values are written with the most-significant digit on the left, and prefixed with "0x".

\subsubsection{Byte Ordering}
The basic data size is the byte (8 bits).
All multi-byte vales are stored in least-significant byte first (``little-endian'') order.
For example, the value 1234 decimal (0x4d2) is stored as the byte stream 0xd2 0x04.

\subsubsection{Integer Types}
Integers can be either signed or unsigned.
Signed values are stored in two's complement form.

\subsubsection{Multi-byte Integer Types}
\begin{center}
\begin{tabular}{l l l l}
\hline
\textbf{Name} & \textbf{Byte Ordering} & \textbf{Integer Type} & \textbf{Size (bytes)} \\
\hline
byte & & unsigned & 1 \\
le\_int32 & little-endian & signed & 4 \\
le\_uint32 & little-endian & unsigned & 4 \\
le\_int64 & little-endian & signed & 8 \\
le\_uint64 & little-endian & unsigned & 8 \\
le\_uint96 & little-endian & unsigned & 12 \\
\end{tabular}
\end{center}

\subsubsection{Structures}
Structure types may be defined (in C-like notation) for convenience.

\begin{verbatim}
struct demo {
  byte string[8];
  le_int32 number1;
  le_uint64 number2;
};
\end{verbatim}

When structures are serialised to a file, elements are written in the given order with no padding between them.
The above structure would be written as twenty bytes - eight for the array `string', four for the integer `number1',
and eight for the integer `number2'.

\subsubsection{Enumerated Types}
Enumerated types may only take one of a given set of values.
The data type used to store the enumerated value is given in angle brackets after the type name.
Every element of an enumerated type must be assigned a value.
It is not valid to compare values between two enumerated types.

\begin{verbatim}
enum Animal<le_uint32> {
  cat    = 1;
  dog    = 2;
  rabbit = 3;
};
\end{verbatim}

\subsubsection{Variants}
Parts of structures may vary depending on information available at the time of decoding.
Which variant to use is selected by an enumerated type.
There must be a case for every possible enumerated value.
Cases have limited fall-through.
Consecutive cases with no fields in between all contain the same fields.

\begin{verbatim}
struct AnimalFeatures {
  select (enum Animal) {
    case cat:
    case dog:
      le_uint32 hairyness;
      le_uint32 whisker_length;

    case rabbit:
      le_uint32 ear_length;
  };
};
\end{verbatim}

For the `cat' and `dog' cases, `struct AnimalFeatures' is eight bytes long and contains two unsigned four-byte
little-endian values.
For the `rabbit' case it is four bytes long and contains a single four-byte little-endian value.

If the cases are different lengths (as above), then the size of the overall structure depends on the variant chosen.
There is NO padding to make the cases the same length unless it is explicitly defined.

\subsection{Header}

The file starts with a header, with the following structure:

\begin{verbatim}
struct Header {
  byte                          magic_number[8];
  le_uint32                     version;
  le_uint32                     header_packet_count;
  Encrypted_header_packet       header_packets[header_packet_count]
};
\end{verbatim}

The \kw{magic\_number} is the ASCII representation of the string ``crypt4gh''.

The version number is stored as a four-byte little-endian unsigned integer.
The current version number is 1.

The current byte representation of the magic number and version is:
\begin{verbatim}
0x63 0x72 0x79 0x70 0x74 0x34 0x67 0x68 0x01 0x00 0x00 0x00
============= magic_number============= ===== version =====
\end{verbatim}

\kw{header\_packet\_count} is the number of header packets that follow.

\subsubsection{Header Packets}\label{header:encryption}

The header packets are defined as:

\begin{verbatim}
enum Header_encryption_method<le_uint32> {
  X25519_chacha20_ietf_poly1305 = 0;
};

struct Header_packet {
  le_uint32                           packet_length;
  Header_encryption_method<le_uint32> packet_encryption;

  select (packet_encryption) {
    case X25519_chacha20_ietf_poly1305:
      byte   public_key[32];
      byte   nonce[12];
  };

  byte encrypted_payload[];
};
\end{verbatim}

\kw{packet\_length} is the length of the entire header packet (including the \kw{packet\_length} itself).
To prevent packet types from being guessed by looking at the size, it is permitted for the \kw{packet\_length} to be
longer than strictly needed to encode all of the packet data.
Any remaining space after the actual data should be padded in a suitable manner (for example by setting it to zero)
and encrypted.

\kw{packet\_encryption} is the encryption method used for this header packet.

\kw{public\_key} and \kw{nonce} are parameters needed to decrypt the \kw{encrypted\_payload} in the packet.

\kw{encrypted\_payload} is the encrypted part of the header packet, for which the plain-text is described below.
For X25519\_chacha20\_ietf\_poly1305 encryption, it includes the 16-byte MAC which is appended after the data.

Implementations should ignore any header packets that they cannot decrypt successfully, as these may have
been intended for a different recipient.

\subsubsection{Header packet encrypted payload}

The \kw{encrypted\_payload} part of the header packet contains the following plain-text:

\begin{verbatim}
enum Header_packet_type<le_uint32> {
  data_encryption_parameters = 0;
  data_edit_list = 1;
};

enum Data_encryption_method<le_uint32> {
  chacha20_ietf_poly1305 = 0;
};

struct Encrypted_header_packet {
  Header_packet_type<le_uint32> packet_type;

  select (packet_type) {
    case data_encryption_parameters:
      enum EncryptionMethod<le_uint32>  data_encryption_method;
      select (data_encryption_method) {
        case chacha20_ietf_poly1305:
          byte  key[32];
      };

    case data_edit_list:
      le_uint32 number_lengths;
      le_uint64 lengths[number_lengths];
  };
};
\end{verbatim}

\kw{packet\_type} defines what sort of data packet this is.

\subsubsection{data\_encryption\_parameters packet}

This packet contains the parameters needed to decrypt the data part of the file.

\kw{data\_encryption\_method} is an enumerated type that describes the type of encryption used.

\kw{key} is the symmetric key used to decode the data section.

To allow parts of the data to be encrypted with different keys, more than one of this packet type may be present.
If there is more than one, the \kw{data\_encryption\_method} MUST be the same for all of them to prevent problems
with random access in the encrypted file.

\subsubsection{data\_edit\_list packet}

The data edit list allows parts of crypt4gh files to be spliced together without needed to re-encrypt parts (or all of)
the files.
Without this it would only be possible to split chacha20\_ietf\_poly1305 data at 64K block boundaries

The list consists of a sequence of \kw{number\_lengths} lengths.
The first length is the number of bytes to discard from the start of the unencrypted data.
The next length (if present) is the number of bytes to keep following the discarded data.
Any remaining lengths are interpreted alternately as the number of bytes to discard, then number of bytes to keep.

If any unencrypted data bytes remain after reaching the end of the edit list, they should be kept if the number of
items in the edit list is odd, and discarded if the number of items is even.
(This is effectively the same as adding an extra element to the list to account of all the remaining bytes, and
interpreting it as described above.)

If more than one edit list is present, only the last one seen should be used.

\subsection{Header packet encryption}

\subsubsection{X25519\_chacha20\_ietf\_poly1305 Encryption}

This method uses Elliptic Curve Diffie-Hellman key exchange with additional hashing to generate a shared key.
The shared key is then used along with a randomly-generated nonce to encrypt the data using the chacha20\_ietf\_poly1305
construction.
The elliptic curve algorithm used is X25519, described in section 5 of \cite{RFC7748}.

Encryption requires the writer's public and secret keys ($K_{pw}$ and $K_{sw}$), the reader's public key ($K_{pr}$)
and a nonce ($N$).

The nonce is a unique initialisation vector.
In chacha20\_ietf\_poly1305 it is 12 bytes long.
This value must be unique for each packet encrypted with the same reader's and writer's keys.
The best way to ensure this is to generate a value with a cryptographically-secure random number generator.

The secret keys MUST be generated using a cryptographically-secure random number generator.
The corresponding public keys are derived using the method in section 6.1 of \cite{RFC7748}.

$K_p = X25519(K_s, 9)$

The writer's secret key and the reader's public key are used to generate a Diffie-Hellman shared key as described in
section 6.1 of \cite{RFC7748}.

$K_{dh} = X25519(K_{sw}, K_{pr})$

As the X25519 algorithm does not produce a completely uniform bit distribution, and many possible $(K_{sw}, K_{pr})$
pairs can produce the same output, the Diffie-Hellman key is hashed along with the two public keys to produce the
final shared key.
The hash function used to do this is Blake2b, as described in \cite{RFC7693}.

$K_s = Blake2b(K_{dh} || K_{pr} || K_{pw})$

As ChaCha20 uses a 32-byte key, only the first 32 bytes of $K_s$ are used; the rest are discarded.

The header packet type, data and any padding is then encrypted using the method described in the
ChaCha20\_IETF\_Poly1305 Encryption section~\ref{data:chacha20_encryption}.
Note that header packets are not segmented; they are always encrypted in a single block.

Finally, the packet length, encryption type, writer's public key $K_{pw}$, the nonce $N$ and the encrypted data are
combined to make the header packet.

For extra security, writers MAY choose to discard the writer's secret key after use.
Due to the symmetry of the Diffie-Hellman algorithm, the holder of either secret key can regenerate the shared
key as long as the other public key is known.
Deleting the writer's key ensures only the holder of the reader's secret key $K_{sr}$ can decode the header packet.
As long as the writer uses randomly-generated keys, it also makes accidental nonce reuse very unlikely.

\subsubsection{X25519\_chacha20\_ietf\_poly1305 Decryption}

To decrypt the header packet, the reader obtains the writer's public key $K_{pw}$ and the nonce from the beginning
of the packet.
Also needed are the reader's public and secret keys ($K_{pr}$ and $K_{sr}$).

The Diffie-Helman key is obtained using:

$K_{dh} = X25519(K_{sr}, K_{pw})$

This is then hashed to obtain the shared key (again only the first 32 bytes are retained):

$K_s = Blake2b(K_{dh} || K_{pr} || K_{pw})$

The resulting key $K_s$ and nonce $N$ are then used to decrypt the remainder of the packet.

If the header packet was intended for a different recipient, the reader will be unable to decode the header packet
as the Poly1305 MAC will be incorrect.
This should not be considered an error.

\subsubsection{Reading the header}

The reader should check that the \kw{magic\_number} and \kw{version} in the header match the expected values.

It should then attempt to decode all of the header packets, ignoring any that do not decrypt successfully.
At the end of this process the reader should have decoded at least one \kw{data\_encryption\_parameters} packet.
If no such packet was decoded, it should report an error.
If more than one is present, they should all have the same \kw{data\_encryption\_method}, otherwise the reader
should report an error.
The reader should all of the keys that it has decoded in a list for use when decoding the encrypted data section.

If a \kw{data\_edit\_list} packet is found, the reader should discard any existing edit list and store the
one it has just decoded.

\subsection{Encrypted Data}
\subsubsection{ChaCha20\_IETF\_Poly1305 Encryption}\label{data:chacha20_encryption}

ChaCha20 is a stream cipher which maps a 256-bit key, nonce and counter to a 512-bit key-stream block.
In IETF mode the nonce is 96 bits long and the counter is 32 bits.
The counter starts at 1, and is incremented by 1 for each successive key-stream block.
The cipher-text is the plain-text message combined with the key-stream using the bit-wise exclusive-or operation.

Poly1305 is used to generate a 16-byte message authentication code (MAC) over the cipher-text.
As the MAC is generated over the entire cipher-text it is not possible to authenticate partially decrypted data.

ChaCha20 and Poly1305 are combined using the AEAD construction described in section 2.8 of \cite{RFC8439}.
This construction allows additional authenticated data (AAD) to be included in the Poly1305 MAC calculation.
For the purposes of this format, the AAD is zero bytes long.

\subsubsection{Segmenting the input}

To allow random access without having to authenticate the entire file, the plain-text is divided into 65536-byte
(64KiB) segments.
If the plain-text is not a multiple of 64KiB long, the last segment will be shorter.
Each segment is encrypted using the method defined in the header.
The nonce used to encrypt the segment is then stored, followed by the encrypted data, and then the MAC.

\begin{verbatim}
struct Segment {
  select (method) {
    case chacha20_ietf_poly1305:
      byte    nonce[12];
      byte[]  encrypted_data;
      byte    mac[16];
  };
};
\end{verbatim}

The addition of the \kw{nonce} and \kw{mac} bytes will expand the data slightly.
For chacha20\_ietf\_poly1305, this expansion will be 28 bytes, so a 65536 byte plain-text input will become a 65564
byte encrypted and authenticated cipher-text output.

\section{Decryption}

The cipher-text is decrypted by authenticating and decrypting the segment(s) enclosing the requested byte range $[P;Q]$,
where $P<Q$.
For a range starting at position $P$, the location of the segment \kw{seg\_start} containing that position must
first be found.
For the chacha20\_ietf\_poly1305 method, when no edit list is in use, this can be done using the formula:

\begin{verbatim}
seg_start = header_len + floor(P/65536) * 65564
\end{verbatim}

For an encrypted segment starting at position \kw{seg\_start}, the nonce, then the 65536 bytes of cipher-text
(possibly fewer of it was the last segment), and finally the MAC are read.

An authentication tag is calculated over the cipher-text from that segment, and bit-wise compared to the MAC.
The cipher-text is authenticated if and only if the tags match.
If more than one key was included in the header, each should be tried in turn until either one authenticates
correctly or no keys are left to try.
An error MUST be reported if the cipher-text is not authenticated.

The key and nonce are then used to decrypt the cipher-text for the segment, returning the plain-text.
Successive segments are decrypted, until the segment containing position $Q$ is reached.
The plain-text segments are concatenated to form the resulting output, discarding $P \mathbin{\%} 65536$ bytes from
the beginning of the first segment and retaining $Q \mathbin{\%} 65536$ bytes of the last one.

If more than one key is in use, readers can speed up decryption by trying the previous successful key first when
attempting to authenticate each block.
However, this does open up a possible timing attack where an observer watching the decoding process can find
out where key changes occur due to the extra time needed to select the new key at these points.
If this is unacceptable, readers could either try each key for every block (although this may still be vulnerable
to timing attacks which try to detect which key was successful); or simply insist that only one key is used for
the whole file.

\subsection{Edit List}

The edit list is designed to assist splicing of encrypted files (for example to remove parts that are not needed
for later analysis) without having to decrypt and re-encrypt the entire file.
It is only possible to splice crypt4gh files at the 64K encryption block boundaries.
The edit list can be used to work around this limitation by describing which parts of the unencrypted blocks
should be discarded to give the final desired plain-text.

The following algorithm describes how to apply the edit list $edlist$ to unencrypted text $input$ to return
the desired edited plain-text.
In this algorithm, function \textsc{IsEmpty} returns true if a list is empty and false if not.
Function \textsc{RemoveFirst} removes the first item from a list and returns it.
\textsc{length} returns the length of a string.
\textsc{substr} returns part of a string from a given zero-based position and with a given length (or shorter if the
requested part extends beyond the end of the input string).
\textsc{StringConcatenate} returns the string concatenation of its input parameters in order from left to right.

\begin{algorithmic}[1]
\Function{ApplyEditList}{$edlist,\ input$}
\If{\Call{IsEmpty}{edlist}}
  \State \textbf{return} $input$\Comment{Trivial case with no edit list}
\EndIf
\settowidth{\maxwidth}{output}
\State \algalign{output}{\gets} ``''\Comment{Initial output is empty}
\State \algalign{pos}{\gets} $0$\Comment{Current position in the unedited plain-text}
\State \algalign{len}{\gets} \Call{length}{input}\Comment{Length of input string}
\Repeat
  \settowidth{\maxwidth}{discard}
  \State \algalign{discard}{\gets} \Call{RemoveFirst}{edlist}\Comment{Pull number of bytes to discard from list}
  \State \algalign{pos}{\gets} $pos + discard$
  \If{\Call{IsEmpty}{edlist}}
     \settowidth{\maxwidth}{output}
     \State \algalign{part}{\gets} \Call{substr}{$input, pos, len - pos$}\Comment{Append the remainder of $input$}
     \State \algalign{output}{\gets} \Call{StringConcatenate}{$output,\ part$}
  \Else
     \settowidth{\maxwidth}{output}
     \State \algalign{keep}{\gets} \Call{RemoveFirst}{edlist}\Comment{Pull number of bytes to keep from the list}
     \State \algalign{part}{\gets} \Call{substr}{$input, pos, keep$}\Comment{Append this part to $output$}
     \State \algalign{output}{\gets} \Call{StringConcatenate}{$output,\ part$}
     \State \algalign{pos}{\gets} $pos + keep$
  \EndIf
\Until{\Call{IsEmpty}{edlist}}
\State \textbf{return} $output$
\EndFunction
\end{algorithmic}

\section{Security Considerations}
\subsection{Threat Model}
This format is designed to protect files at rest and in transport from accidental disclosure.
Using authenticated encryption in individual segments mirrors solutions like Transport Layer
Security (TLS) as described in~\cite{RFC5246} and prevents undetected modification of segments.

\subsection{Selection of Keys}
The security of the format depends on attackers not being able to guess the header secure keys or the encryption key.
The keys MUST be generated using a cryptographically-secure pseudo-random number generator.
This makes the chance of guessing a key vanishingly small.

\subsection{Nonce selection}
All header packets encrypted with the same combination of writer's secret key and reader's public key MUST use a unique
nonce.
If the writer uses the same secret key for more than one file then all nonces MUST be unique across all files made
with that key.
As each file will only include a few header packets this restriction can be fulfilled by generating each nonce
using a cryptographically-secure random number generator.
If the writer uses randomly-generated keys for each file, or even each header packet, the risk of nonce reuse in
the header is almost completely eliminated.

All data segments encrypted with the same key MUST use a unique nonce.
One way to ensure this is to choose a random starting point and then use a counter or linear-feedback shift
register to generate the nonce for each segment.
This method guarantees a unique value even for very long files.

For a 96-bit nonce, it may be acceptable to generate each one using a cryptographically-secure pseudo-random number
generator.
Care should be taken to ensure that the random number generator is capable of generating a long enough stream
of unique values.
Due to the birthday problem, this method will have a non-zero (but very small) probability of failing.
For example, a file of 24 Terabytes will have a reused nonce with probability of approximately $10^{-12}$

\subsection{Message Forgery}
Using ChaCha20-ietf-Poly1305 authenticates the content of each header packet and each segment of the encrypted
cipher-text.
It does not protect against the addition or removal of header packets, or the addition, removal or rearrangement
of data segments.
crypt4gh files are not signed, so there is no direct way to prove that a file was created by a given writer.

\subsection{No File Updates Permitted}
Implementations MUST NOT update encrypted files.
Once written, a section of the file must never be altered.

\addcontentsline{toc}{section}{References}
\bibliographystyle{abstract}

\renewcommand{\refname}{\section{References}} % Get References numbered correctly in the table of contents
\begin{thebibliography}{XXXXXXX}

% Normative references

\bibitem[RFC2119]{RFC2119}
  Bradner, S.,\\
  \emph{"Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119},\\
  \url{https://www.rfc-editor.org/info/rfc2119},\\
  March 1997

\bibitem[RFC7693]{RFC7693}
  Saarinen, M.J., Aumasson, J.P.\\
  \emph{"The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)", RFC7693},\\
  \url{https://tools.ietf.org/html/rfc7693},\\
  November 2015

\bibitem[RFC7748]{RFC7748}
  A. Langley, Google, M. Hamburg, Rambus Cryptography Research, S. Turner, sn3rd,\\
  \emph{"Elliptic Curves for Security", RFC7748},\\
  \url{https://tools.ietf.org/html/rfc7748},\\
  January 2016

\bibitem[RFC8032]{RFC8032}
  S. Josefsson, SJD AB, I. Liusvaara,\\
  \emph{"Edwards-Curve Digital Signature Algorithm (EdDSA)", RFC8032},\\
  \url{https://tools.ietf.org/html/rfc8032},\\
  January 2017

\bibitem[RFC8439]{RFC8439}
  Y. Nir, Dell EMC, A. Langley, Google, Inc.,\\
  \emph{"ChaCha20 and Poly1305 for IETF Protocols", RFC8439},\\
  \url{https://tools.ietf.org/html/rfc8439},\\
  June 2018

% Informational references

\bibitem[RFC5246]{RFC5246}
  Dierks, T., Rescorla, E.,\\
  \emph{"The Transport Layer Security (TLS) Protocol Version 1.2", RFC 5246},\\
  \url{https://www.rfc-editor.org/info/rfc5246},\\
  August 2008.

\end{thebibliography}

\end{document}
